package main

import (
	"context"
	"fmt"
	"log"
	"os"
	"os/signal"
	"sync"
	"syscall"

	"github.com/IAmRiteshKoushik/termite/consumer"
	"github.com/IAmRiteshKoushik/termite/pkg"
)

func main() {
	var err error

	// Load configuration
	if err := pkg.LoadConfig(); err != nil {
		log.Fatalf("Failed to load configuration: %v", err)
	}

	// Logger init
	pkg.Log, err = pkg.InitLogger(pkg.AppConfig.LogEnv)
	if err != nil {
		log.Fatalf("Failed to initialize logger: %v", err)
	}
	pkg.Log.Info("[OK]: Logger initialized successfully")

	// Initialize message broker
	pkg.Rabbit, err = pkg.NewBroker(pkg.AppConfig.RabbitMQURL)
	if err != nil {
		pkg.Log.Fatal("[BAD]: Failed to initialize message broker", err)
	}
	defer func() {
		if err := pkg.Rabbit.Close(); err != nil {
			pkg.Log.Error("[BAD]: Failed to close RabbitMQ connection", err)
		} else {
			pkg.Log.Info("[OK]: RabbitMQ connection closed successfully.")
		}
	}()
	pkg.Log.Info("[OK]: Message broker initialized successfully")

	// Create a raw context and pass into the consumer routines. This allows us
	// to propagate background state like cancellation SIGNALS into the consumer
	// goroutines
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	// Channel to listen for OS signals. It is a buffered channel with size 1
	// so that the channel remains unblocking and does not stop the LOC that follow
	// it from executing.
	sigChan := make(chan os.Signal, 1)
	// SIGINT means Signal Interrupt. This is the signal generated for CTRL + C
	// SIGTERM means Signal Terminate. This is the signal generated by processes
	// like Docker, Kubernetes, systemd, pm2 .etc, to tell a program to stop
	// executing.
	signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)

	// WaitGroup to receive confirmation when the consumer has shutdown
	// successfully so that we can exit the goroutine without any consumer's
	// work getting hampered in between
	var wg sync.WaitGroup

	wocConsumer := consumer.NewWocConsumer(pkg.Rabbit.Conn())
	aiConsumer := consumer.NewAiConsumer(pkg.Rabbit.Conn())

	wg.Add(1)
	go func() {
		defer wg.Done() // Is executed when the consumer stops / errors out.
		if err := wocConsumer.Listen(ctx); err != nil {
			pkg.Log.Error("WOC consumer stopped with an error", err)
		}
	}()

	wg.Add(1)
	go func() {
		defer wg.Done()
		if err := aiConsumer.Listen(ctx); err != nil {
			pkg.Log.Error("AI consumer stopped with an error", err)
		}
	}()

	pkg.Log.Info("Consumers are up and running. Press CTRL+C to exit.")
	// This is where the main goroutine halts. If it gets either SIGTERM or SIGINT
	// then that signal is received here. The use of the variable to capture the
	// signal is not mandatory but it is a good practice as you will be able to
	// see in the logs, which kind of signal stopped it. (can help in debugging)
	sig := <-sigChan
	msg := fmt.Sprintf("Shutdown signal received: %s. Shutting down gracefully...", sig)
	pkg.Log.Info(msg)

	cancel() // Stop all goroutines. After they are done, their respective
	// wg.Done() functions will be executed. When all of then are executed, the
	// wg will hold a 0-value and the Wait() function will not be blocking anymore
	wg.Wait() // Wait for all goroutines to cleanup

	pkg.Log.Info("All consumers have shut down. Exiting.")
}
